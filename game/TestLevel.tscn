[gd_scene load_steps=8 format=2]

[ext_resource path="res://game/Player.tscn" type="PackedScene" id=1]

<<<<<<< HEAD
[sub_resource type="Shader" id=1]
=======
[sub_resource type="SpatialMaterial" id=6]
params_diffuse_mode = 4
albedo_color = Color( 0.501961, 0.501961, 0.501961, 1 )
metallic = 1.0
roughness = 0.0

[sub_resource type="Shader" id=2]
>>>>>>> 24079b4 (main menu)
code = "shader_type spatial;

vec4 mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float mod289(float x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute_4(vec4 x) {
    return mod289_4(((x * 34.0) + 1.0) * x);
}

float permute(float x) {
    return mod289(((x * 34.0) + 1.0) * x);
}

vec4 taylorInvSqrt_4(vec4 r) {
    return 2.79284291400159 - 1.85373472095314 * r;
}

float taylorInvSqrt(float r) {
    return 2.79284291400159 - 1.85373472095314 * r;
}

vec4 grad4(float j, vec4 ip) {
	vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
	vec4 p, s;

	p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
	p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
	s = vec4(lessThan(p, vec4(0.0)));
	p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

	return p;
}

float snoise(vec4 v) {
    vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                    0.276393202250021,  // 2 * G4
                    0.414589803375032,  // 3 * G4
                   -0.447213595499958); // -1 + 4 * G4
    
    // First corner
    vec4 i  = floor(v + dot(v, vec4(0.309016994374947451)) ); //// (sqrt(5) - 1)/4
    vec4 x0 = v -   i + dot(i, C.xxxx);
    
    // Other corners
    
    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
    vec4 i0;
    vec3 isX = step( x0.yzw, x0.xxx );
    vec3 isYZ = step( x0.zww, x0.yyz );
    //  i0.x = dot( isX, vec3( 1.0 ) );
    i0.x = isX.x + isX.y + isX.z;
    i0.yzw = 1.0 - isX;
    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
    i0.y += isYZ.x + isYZ.y;
    i0.zw += 1.0 - isYZ.xy;
    i0.z += isYZ.z;
    i0.w += 1.0 - isYZ.z;
    
    // i0 now contains the unique values 0,1,2,3 in each channel
    vec4 i3 = clamp( i0, 0.0, 1.0 );
    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );
    
    //  x0 = x0 - 0.0 + 0.0 * C.xxxx
    //  x1 = x0 - i1  + 1.0 * C.xxxx
    //  x2 = x0 - i2  + 2.0 * C.xxxx
    //  x3 = x0 - i3  + 3.0 * C.xxxx
    //  x4 = x0 - 1.0 + 4.0 * C.xxxx
    vec4 x1 = x0 - i1 + C.xxxx;
    vec4 x2 = x0 - i2 + C.yyyy;
    vec4 x3 = x0 - i3 + C.zzzz;
    vec4 x4 = x0 + C.wwww;
    
    // Permutations
    i = mod289_4(i);
    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
    vec4 j1 = permute_4( permute_4( permute_4( permute_4 (
                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
    
    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.
    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;
    
    vec4 p0 = grad4(j0,   ip);
    vec4 p1 = grad4(j1.x, ip);
    vec4 p2 = grad4(j1.y, ip);
    vec4 p3 = grad4(j1.z, ip);
    vec4 p4 = grad4(j1.w, ip);
    
    // Normalise gradients
    vec4 norm = taylorInvSqrt_4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    p4 *= taylorInvSqrt(dot(p4,p4));
    
    // Mix contributions from the five corners
    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), vec3(0.0));
    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)), vec2(0.0));
    m0 = m0 * m0;
    m1 = m1 * m1;
    return 33.0 * (dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
}

// Torus signed distance field function
float SDFTorus(vec3 p, float innerRadius, float radius) {
	vec2 q = vec2(length(p.xz) - radius, p.y);
	return length(q) - innerRadius;
}

// Sphere signed distance field function
float SDFSphere(vec3 p, float radius) {
	return length(p) - radius;
}

// Box signed distance field function
float SDFBox(vec3 p, vec3 size) {
	vec3 d = abs(p) - size;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

//http://www.fractalforums.com/ifs-iterated-function-systems/revenge-of-the-half-eaten-menger-sponge/15/
float mengersponge_de(int n, vec3 pos) { //by recursively digging a box
	float x=pos.x, y=pos.y, z=pos.z;
	x=x*0.5+0.5;y=y*0.5+0.5;z=z*0.5+0.5; //center it by changing position and scale

	float xx=abs(x-0.5)-0.5, yy=abs(y-0.5)-0.5, zz=abs(z-0.5)-0.5;
	float d1=max(xx,max(yy,zz)); //distance to the box
	float d=d1; //current computed distance
	float p=1.0;
	for (int i=1; i<=n; ++i) {
		float xa = mod(3.0*x*p,3.0);
		float ya = mod(3.0*y*p,3.0);
		float za = mod(3.0*z*p,3.0);
		p*=3.0;
		//we can also translate/rotate (xa,ya,za) without affecting the DE estimate

		xx=0.5-abs(xa-1.5); yy=0.5-abs(ya-1.5); zz=0.5-abs(za-1.5);
		d1=min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p; //distance inside the 3 axis-aligned square tubes

		d=max(d,d1); //intersection
	}
	//return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function
	return d;
}

vec3 opRep(vec3 p, vec3 c) {
    vec3 q = mod(p+0.5*c,c)-0.5*c;
    return q;
}

void rotX(inout vec4 z, float s, float c) {
	z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);
}
void rotY(inout vec4 z, float s, float c) {
	z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);
}
void rotZ(inout vec4 z, float s, float c) {
	z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);
}
void rotXX(inout vec4 z, float a) {
	rotX(z, sin(a), cos(a));
}
void rotYY(inout vec4 z, float a) {
	rotY(z, sin(a), cos(a));
}
void rotZZ(inout vec4 z, float a) {
	rotZ(z, sin(a), cos(a));
}

// Sample the whole scene, you can mix multiple shapes here
float Scene(vec3 pos) {
	//return snoise(vec4(pos*0.01, 0.1*TIME));
	//return SDFBox(pos, vec3(1.0, 1.0, 1.0));
	//return mengersponge_de(6, (pos-vec3(-160.0, 55.0, 0.0))*0.2);
	pos = opRep(pos, vec3(100.0));
	vec4 rotated = vec4(pos, 0.0);
	rotXX(rotated, snoise(vec4(pos*0.01, TIME)));
	pos = rotated.xyz;
	float d = SDFBox(pos, vec3(20.0));
	return d;
}

// Raymarching constants
const float SURFACE_DST = .01;
const int MAX_STEPS = 64;
const float MAX_DISTANCE = 1024f;
const float NORMAL_STEP = .01f;

// The actual raymarching function
float RayMarch(vec3 ro, vec3 rd) {
	float d = 0f;
	for (int i = 0; i < MAX_STEPS; i++) {
		vec3 pos = ro + rd * d;
		float sceneDst = Scene(pos);
		
		d += sceneDst;
		
		// Only stop if distance is higher than MAX_DISTANCE or sampled distance
		// is less that surface threshold
		if (d > MAX_DISTANCE || abs(sceneDst) <= SURFACE_DST) break;
	}
	return d;
}

// Sample the world normal in the contact position
vec3 Normal(vec3 pos) {
	float d = Scene(pos);
	vec2 e = vec2(NORMAL_STEP, 0.0);
	vec3 n = d - vec3(
		Scene(pos - e.xyy),
		Scene(pos - e.yxy),
		Scene(pos - e.yyx));
	return normalize(n);
}

varying float time;

void vertex() {
	time = TIME;
}

void fragment() {
	// Get the pixel world coordinates
	vec3 world = (CAMERA_MATRIX * vec4(VERTEX, 1.0)).xyz;
	// Get the camera position
	vec3 camera = (CAMERA_MATRIX * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
	// Raymarching direction
	vec3 dir = normalize(world - camera);
	
	// Starts just a bit off the mesh surface
	vec3 ro = world - dir * SURFACE_DST;
	vec3 rd = dir;
	
	// Raymarch
	float d = RayMarch(ro, rd);
	// Set the world position from the raymarching output
	world = ro + rd * d;
	
	if (d >= MAX_DISTANCE) discard;
	
	// Samples world normal
	vec3 n = Normal(world);
	// Set the local normal relative to the view
	NORMAL = (INV_CAMERA_MATRIX * vec4(n, 0f)).xyz;
	
	// Depth calculation, this makes possible for other meshes intersect
	// properly with the geometry
	vec4 ndc = PROJECTION_MATRIX * INV_CAMERA_MATRIX * vec4(world, 1f);
	float depth = (ndc.z / ndc.w) * .5f + .5f;
	DEPTH = depth;
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )

[sub_resource type="CubeMesh" id=3]
material = SubResource( 2 )
size = Vector3( 10, 500, 1000 )

[sub_resource type="ProceduralSky" id=4]

[sub_resource type="Environment" id=5]
background_mode = 2
background_sky = SubResource( 4 )
tonemap_mode = 4
tonemap_exposure = 1.15
tonemap_white = 1.21
ss_reflections_enabled = true
glow_intensity = 1.36
glow_strength = 0.93
glow_bloom = 0.17

[node name="TestLevel" type="Spatial"]

[node name="Player" parent="." instance=ExtResource( 1 )]
<<<<<<< HEAD
transform = Transform( 1, 0, 0, 0, 0.993776, 0.1114, 0, -0.1114, 0.993776, 0.0284064, 2.38419e-07, -0.0269072 )
=======
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -1.33383, 0 )
>>>>>>> 24079b4 (main menu)

[node name="CSGBox" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -4, 0 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox2" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.965926, -0.258819, 0, 0.258819, 0.965926, 0, 0, -30 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox6" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.965926, 0.258819, 0, -0.258819, 0.965926, 0, 0, 30 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox3" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.866025, -0.5, 0, 0.5, 0.866025, 0, 8, -49 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox7" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.866025, 0.5, 0, -0.5, 0.866025, 0, 8, 49 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox4" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.707107, -0.707107, 0, 0.707107, 0.707107, 0, 15, -63 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox8" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.707107, 0.707107, 0, -0.707107, 0.707107, 0, 15, 63 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox5" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.5, -0.866025, 0, 0.866025, 0.5, 0, 28, -76 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox9" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.5, 0.866025, 0, -0.866025, 0.5, 0, 28, 76 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox10" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.258819, 0.965925, 0, -0.965925, 0.258819, 0, 55, 88 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="CSGBox11" type="CSGBox" parent="."]
transform = Transform( 1, 0, 0, 0, 0.258819, -0.965925, 0, 0.965925, 0.258819, 0, 55, -88 )
use_collision = true
width = 54.0
depth = 46.0
material = SubResource( 6 )

[node name="DirectionalLight" type="DirectionalLight" parent="."]
transform = Transform( 0.965926, -7.71341e-09, -0.258819, 0.258819, 2.87868e-08, 0.965926, 0, -1, 2.98023e-08, 0, 9.81304, 0 )
shadow_enabled = true

[node name="MeshInstance" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -281, 55, 0 )
<<<<<<< HEAD
mesh = SubResource( 3 )
=======
visible = false
mesh = SubResource( 1 )
>>>>>>> 24079b4 (main menu)
material/0 = null

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource( 5 )
